var __importDefault=this&&this.__importDefault||function(a){return a&&a.__esModule?a:{"default":a}};Object.defineProperty(exports,"__esModule",{value:!0});exports.makeEventBuffer=void 0;
const events_1=__importDefault(require("events")),Types_1=require("../Types"),generics_1=require("./generics"),messages_1=require("./messages"),process_message_1=require("./process-message"),BUFFERABLE_EVENT="messaging-history.set chats.upsert chats.update chats.delete contacts.upsert contacts.update messages.upsert messages.update messages.delete messages.reaction message-receipt.update groups.update".split(" "),BUFFERABLE_EVENT_SET=new Set(BUFFERABLE_EVENT),makeEventBuffer=a=>{function b(){t+=1}
function e(f=!1){if(!t||!f&&--t)return!1;f=makeBufferData();const k=Object.values(n.chatUpdates);let l=0;for(var g of k)g.conditional&&(l+=1,f.chatUpdates[g.id]=g,delete n.chatUpdates[g.id]);g=consolidateEvents(n);Object.keys(g).length&&d.emit("event",g);n=f;a.trace({conditionalChatUpdatesLeft:l},"released buffered events");return!0}const d=new events_1.default,m=new Set;let n=makeBufferData(),t=0;d.on("event",f=>{for(const k in f)d.emit(k,f[k])});return{process(f){const k=l=>{f(l)};d.on("event",
k);return()=>{d.off("event",k)}},emit(f,k){return t&&BUFFERABLE_EVENT_SET.has(f)?(append(n,m,f,k,a),!0):d.emit("event",{[f]:k})},isBuffering(){return 0<t},buffer:b,flush:e,createBufferedFunction(f){return async(...k)=>{b();try{return await f(...k)}finally{e()}}},on:(...f)=>d.on(...f),off:(...f)=>d.off(...f),removeAllListeners:(...f)=>d.removeAllListeners(...f)}};exports.makeEventBuffer=makeEventBuffer;
const makeBufferData=()=>({historySets:{chats:{},messages:{},contacts:{},isLatest:!1,empty:!0},chatUpserts:{},chatUpdates:{},chatDeletes:new Set,contactUpserts:{},contactUpdates:{},messageUpserts:{},messageUpdates:{},messageReactions:{},messageDeletes:{},messageReceipts:{},groupUpdates:{}});
function append(a,b,e,d,m){function n(q){const h=q.id,c=a.chatUpdates[h];if(c){const p=c.conditional?c.conditional(a):!0;p?(delete c.conditional,m.debug({chatId:h},"absorbed chat update in existing chat"),Object.assign(q,concatChats(c,q)),delete a.chatUpdates[h]):!1===p&&(m.debug({chatId:h},"chat update condition fail, removing"),delete a.chatUpdates[h])}}function t(q){var h=q.key.remoteJid;h=a.chatUpdates[h]||a.chatUpserts[h];(0,process_message_1.isRealMessage)(q,"")&&(0,process_message_1.shouldIncrementChatUnread)(q)&&
"number"===typeof(null===h||void 0===h?void 0:h.unreadCount)&&0<h.unreadCount&&(m.debug({chatId:h.id},"decrementing chat counter"),--h.unreadCount,0===h.unreadCount&&delete h.unreadCount)}var f,k,l;switch(e){case "messaging-history.set":for(const c of d.chats){if(l=a.historySets.chats[c.id])l.endOfHistoryTransferType=c.endOfHistoryTransferType;l||b.has(c.id)||(a.historySets.chats[c.id]=c,b.add(c.id),n(c))}for(var g of d.contacts)if(l=a.historySets.contacts[g.id])Object.assign(l,(0,generics_1.trimUndefined)(g));
else{l=`c:${g.id}`;var r=g.notify||g.name||g.verifiedName;if(!b.has(l)||r)a.historySets.contacts[g.id]=g,b.add(l)}for(const c of d.messages)g=stringifyMessageKey(c.key),a.historySets.messages[g]||b.has(g)||(a.historySets.messages[g]=c,b.add(g));a.historySets.empty=!1;a.historySets.syncType=d.syncType;a.historySets.progress=d.progress;a.historySets.peerDataRequestSessionId=d.peerDataRequestSessionId;a.historySets.isLatest=d.isLatest||a.historySets.isLatest;break;case "chats.upsert":for(const c of d)b=
a.chatUpserts[c.id],b||(b=a.historySets[c.id])&&m.debug({chatId:c.id},"absorbed chat upsert in chat set"),b?b=concatChats(b,c):(b=c,a.chatUpserts[c.id]=b),n(b),a.chatDeletes.has(c.id)&&a.chatDeletes.delete(c.id);break;case "chats.update":for(r of d)b=r.id,(d=r.conditional?r.conditional(a):!0)?(delete r.conditional,(d=a.historySets.chats[b]||a.chatUpserts[b])?concatChats(d,r):a.chatUpdates[b]=concatChats(a.chatUpdates[b]||{},r)):void 0===d&&(a.chatUpdates[b]=r),a.chatDeletes.has(b)&&a.chatDeletes.delete(b);
break;case "chats.delete":for(const c of d)a.chatDeletes.has(c)||a.chatDeletes.add(c),a.chatUpdates[c]&&delete a.chatUpdates[c],a.chatUpserts[c]&&delete a.chatUpserts[c],a.historySets.chats[c]&&delete a.historySets.chats[c];break;case "contacts.upsert":for(const c of d)b=a.contactUpserts[c.id],b||(b=a.historySets.contacts[c.id])&&m.debug({contactId:c.id},"absorbed contact upsert in contact set"),b?b=Object.assign(b,(0,generics_1.trimUndefined)(c)):(b=c,a.contactUpserts[c.id]=b),a.contactUpdates[c.id]&&
(b=Object.assign(a.contactUpdates[c.id],(0,generics_1.trimUndefined)(c)),delete a.contactUpdates[c.id]);break;case "contacts.update":for(const c of d)b=c.id,(d=a.historySets.contacts[b]||a.contactUpserts[b])?Object.assign(d,c):a.contactUpdates[b]=Object.assign(a.contactUpdates[b]||{},c);break;case "messages.upsert":const {messages:q,type:h}=d;for(const c of q)b=stringifyMessageKey(c.key),d=null===(f=a.messageUpserts[b])||void 0===f?void 0:f.message,d||(d=a.historySets.messages[b])&&m.debug({messageId:b},
"absorbed message upsert in message set"),d&&(c.messageTimestamp=d.messageTimestamp),a.messageUpdates[b]&&(m.debug("absorbed prior message update in message upsert"),Object.assign(c,a.messageUpdates[b].update),delete a.messageUpdates[b]),a.historySets.messages[b]?a.historySets.messages[b]=c:a.messageUpserts[b]={message:c,type:"notify"===h||"notify"===(null===(k=a.messageUpserts[b])||void 0===k?void 0:k.type)?"notify":h};break;case "messages.update":for(const {key:c,update:p}of d)b=stringifyMessageKey(c),
(d=a.historySets.messages[b]||(null===(l=a.messageUpserts[b])||void 0===l?void 0:l.message))?(Object.assign(d,p),p.status!==Types_1.WAMessageStatus.READ||c.fromMe||t(d)):(d=a.messageUpdates[b]||{key:c,update:{}},Object.assign(d.update,p),a.messageUpdates[b]=d);break;case "messages.delete":if("keys"in d){({keys:b}=d);for(const c of b)b=stringifyMessageKey(c),a.messageDeletes[b]||(a.messageDeletes[b]=c),a.messageUpserts[b]&&delete a.messageUpserts[b],a.messageUpdates[b]&&delete a.messageUpdates[b]}break;
case "messages.reaction":for(const {key:c,reaction:p}of d)b=stringifyMessageKey(c),(d=a.messageUpserts[b])?(0,messages_1.updateMessageWithReaction)(d.message,p):(a.messageReactions[b]=a.messageReactions[b]||{key:c,reactions:[]},(0,messages_1.updateMessageWithReaction)(a.messageReactions[b],p));break;case "message-receipt.update":for(const {key:c,receipt:p}of d)b=stringifyMessageKey(c),(d=a.messageUpserts[b])?(0,messages_1.updateMessageWithReceipt)(d.message,p):(a.messageReceipts[b]=a.messageReceipts[b]||
{key:c,userReceipt:[]},(0,messages_1.updateMessageWithReceipt)(a.messageReceipts[b],p));break;case "groups.update":for(const c of d)b=c.id,d=a.groupUpdates[b]||{},a.groupUpdates[b]||(a.groupUpdates[b]=Object.assign(d,c));break;default:throw Error(`"${e}" cannot be buffered`);}}
function consolidateEvents(a){const b={};a.historySets.empty||(b["messaging-history.set"]={chats:Object.values(a.historySets.chats),messages:Object.values(a.historySets.messages),contacts:Object.values(a.historySets.contacts),syncType:a.historySets.syncType,progress:a.historySets.progress,isLatest:a.historySets.isLatest,peerDataRequestSessionId:a.historySets.peerDataRequestSessionId});var e=Object.values(a.chatUpserts);e.length&&(b["chats.upsert"]=e);e=Object.values(a.chatUpdates);e.length&&(b["chats.update"]=
e);e=Array.from(a.chatDeletes);e.length&&(b["chats.delete"]=e);e=Object.values(a.messageUpserts);if(e.length){const d=e[0].type;b["messages.upsert"]={messages:e.map(m=>m.message),type:d}}e=Object.values(a.messageUpdates);e.length&&(b["messages.update"]=e);e=Object.values(a.messageDeletes);e.length&&(b["messages.delete"]={keys:e});e=Object.values(a.messageReactions).flatMap(({key:d,reactions:m})=>m.flatMap(n=>({key:d,reaction:n})));e.length&&(b["messages.reaction"]=e);e=Object.values(a.messageReceipts).flatMap(({key:d,
userReceipt:m})=>m.flatMap(n=>({key:d,receipt:n})));e.length&&(b["message-receipt.update"]=e);e=Object.values(a.contactUpserts);e.length&&(b["contacts.upsert"]=e);e=Object.values(a.contactUpdates);e.length&&(b["contacts.update"]=e);a=Object.values(a.groupUpdates);a.length&&(b["groups.update"]=a);return b}
function concatChats(a,b){null===b.unreadCount&&0>a.unreadCount&&(a.unreadCount=void 0,b.unreadCount=void 0);"number"===typeof a.unreadCount&&"number"===typeof b.unreadCount&&(b={...b},0<=b.unreadCount&&(b.unreadCount=Math.max(b.unreadCount,0)+Math.max(a.unreadCount,0)));return Object.assign(a,b)}const stringifyMessageKey=a=>`${a.remoteJid},${a.id},${a.fromMe?"1":"0"}`;
