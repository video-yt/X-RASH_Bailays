Object.defineProperty(exports,"__esModule",{value:!0});exports.getNextPreKeysNode=exports.getNextPreKeys=exports.extractDeviceJids=exports.parseAndInjectE2ESessions=exports.xmppPreKey=exports.xmppSignedPreKey=exports.generateOrGetPreKeys=exports.getPreKeys=exports.createSignalIdentity=void 0;
const lodash_1=require("lodash"),Defaults_1=require("../Defaults"),WABinary_1=require("../WABinary"),crypto_1=require("./crypto"),generics_1=require("./generics"),createSignalIdentity=(a,b)=>({identifier:{name:a,deviceId:0},identifierKey:(0,crypto_1.generateSignalPubKey)(b)});exports.createSignalIdentity=createSignalIdentity;const getPreKeys=async({get:a},b,c)=>{const f=[];for(;b<c;b++)f.push(b.toString());return a("pre-key",f)};exports.getPreKeys=getPreKeys;
const generateOrGetPreKeys=(a,b)=>{var c=b-(a.nextPreKeyId-a.firstUnuploadedPreKeyId);const f=a.nextPreKeyId+c-1,d={};if(0<c)for(c=a.nextPreKeyId;c<=f;c++)d[c]=crypto_1.Curve.generateKeyPair();return{newPreKeys:d,lastPreKeyId:f,preKeysRange:[a.firstUnuploadedPreKeyId,b]}};exports.generateOrGetPreKeys=generateOrGetPreKeys;
const xmppSignedPreKey=a=>({tag:"skey",attrs:{},content:[{tag:"id",attrs:{},content:(0,generics_1.encodeBigEndian)(a.keyId,3)},{tag:"value",attrs:{},content:a.keyPair.public},{tag:"signature",attrs:{},content:a.signature}]});exports.xmppSignedPreKey=xmppSignedPreKey;const xmppPreKey=(a,b)=>({tag:"key",attrs:{},content:[{tag:"id",attrs:{},content:(0,generics_1.encodeBigEndian)(b,3)},{tag:"value",attrs:{},content:a.public}]});exports.xmppPreKey=xmppPreKey;
const parseAndInjectE2ESessions=async(a,b)=>{const c=d=>d?{keyId:(0,WABinary_1.getBinaryNodeChildUInt)(d,"id",3),publicKey:(0,crypto_1.generateSignalPubKey)((0,WABinary_1.getBinaryNodeChildBuffer)(d,"value")),signature:(0,WABinary_1.getBinaryNodeChildBuffer)(d,"signature")}:void 0;a=(0,WABinary_1.getBinaryNodeChildren)((0,WABinary_1.getBinaryNodeChild)(a,"list"),"user");for(var f of a)(0,WABinary_1.assertNodeErrorFree)(f);f=(0,lodash_1.chunk)(a,100);for(const d of f)await Promise.all(d.map(async e=>
{const h=(0,WABinary_1.getBinaryNodeChild)(e,"skey"),l=(0,WABinary_1.getBinaryNodeChild)(e,"key"),k=(0,WABinary_1.getBinaryNodeChildBuffer)(e,"identity"),g=e.attrs.jid;e=(0,WABinary_1.getBinaryNodeChildUInt)(e,"registration",4);await b.injectE2ESession({jid:g,session:{registrationId:e,identityKey:(0,crypto_1.generateSignalPubKey)(k),signedPreKey:c(h),preKey:c(l)}})}))};exports.parseAndInjectE2ESessions=parseAndInjectE2ESessions;
const extractDeviceJids=(a,b,c)=>{const {user:f,device:d}=(0,WABinary_1.jidDecode)(b);b=[];for(const e of a){const {devices:h,id:l}=e;({user:a}=(0,WABinary_1.jidDecode)(l));const k=null===h||void 0===h?void 0:h.deviceList;if(Array.isArray(k))for(const {id:g,keyIndex:m}of k)c&&0===g||f===a&&d===g||0!==g&&!m||b.push({user:a,device:g})}return b};exports.extractDeviceJids=extractDeviceJids;
const getNextPreKeys=async({creds:a,keys:b},c)=>{const {newPreKeys:f,lastPreKeyId:d,preKeysRange:e}=(0,exports.generateOrGetPreKeys)(a,c);a={nextPreKeyId:Math.max(d+1,a.nextPreKeyId),firstUnuploadedPreKeyId:Math.max(a.firstUnuploadedPreKeyId,d+1)};await b.set({"pre-key":f});b=await (0,exports.getPreKeys)(b,e[0],e[0]+e[1]);return{update:a,preKeys:b}};exports.getNextPreKeys=getNextPreKeys;
const getNextPreKeysNode=async(a,b)=>{const {creds:c}=a,{update:f,preKeys:d}=await (0,exports.getNextPreKeys)(a,b);a={tag:"iq",attrs:{xmlns:"encrypt",type:"set",to:WABinary_1.S_WHATSAPP_NET},content:[{tag:"registration",attrs:{},content:(0,generics_1.encodeBigEndian)(c.registrationId)},{tag:"type",attrs:{},content:Defaults_1.KEY_BUNDLE_TYPE},{tag:"identity",attrs:{},content:c.signedIdentityKey.public},{tag:"list",attrs:{},content:Object.keys(d).map(e=>(0,exports.xmppPreKey)(d[+e],+e))},(0,exports.xmppSignedPreKey)(c.signedPreKey)]};
return{update:f,node:a}};exports.getNextPreKeysNode=getNextPreKeysNode;
