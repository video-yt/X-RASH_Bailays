var __importDefault=this&&this.__importDefault||function(d){return d&&d.__esModule?d:{"default":d}};Object.defineProperty(exports,"__esModule",{value:!0});exports.initAuthCreds=exports.addTransactionCapability=void 0;exports.makeCacheableSignalKeyStore=makeCacheableSignalKeyStore;const node_cache_1=__importDefault(require("@cacheable/node-cache")),crypto_1=require("crypto"),Defaults_1=require("../Defaults"),crypto_2=require("./crypto"),generics_1=require("./generics");
function makeCacheableSignalKeyStore(d,h,n){const k=n||new node_cache_1.default({stdTTL:Defaults_1.DEFAULT_CACHE_TTLS.SIGNAL_STORE,useClones:!1,deleteOnExpire:!0});return{async get(f,e){const g={};var b=[];for(var a of e)e=k.get(`${f}.${a}`),"undefined"!==typeof e?g[a]=e:b.push(a);if(b.length){null===h||void 0===h||h.trace({items:b.length},"loading from store");a=await d.get(f,b);for(const c of b)if(b=a[c])g[c]=b,k.set(`${f}.${c}`,b)}return g},async set(f){let e=0;for(const g in f)for(const b in f[g])k.set(`${g}.${b}`,
f[g][b]),e+=1;null===h||void 0===h||h.trace({keys:e},"updated cache");await d.set(f)},async clear(){var f;k.flushAll();await (null===(f=d.clear)||void 0===f?void 0:f.call(d))}}}
const addTransactionCapability=(d,h,{maxCommitRetries:n,delayBetweenTriesMs:k})=>{let f=0,e={},g={},b=0;return{get:async(a,c)=>{if(0<b){const q=e[a];var l=q?c.filter(m=>"undefined"===typeof q[m]):c;l.length&&(f+=1,l=await d.get(a,l),e[a]||(e[a]={}),Object.assign(e[a],l));return c.reduce((m,r)=>{var p;const t=null===(p=e[a])||void 0===p?void 0:p[r];t&&(m[r]=t);return m},{})}return d.get(a,c)},set:a=>{if(0<b){h.trace({types:Object.keys(a)},"caching in transaction");for(const c in a)e[c]=e[c]||{},Object.assign(e[c],
a[c]),g[c]=g[c]||{},Object.assign(g[c],a[c])}else return d.set(a)},isInTransaction:function(){return 0<b},async transaction(a){let c;b+=1;1===b&&h.trace("entering transaction");try{if(c=await a(),1===b)if(Object.keys(g).length)for(h.trace("committing transaction"),a=n;a;){--a;try{await d.set(g);h.trace({dbQueriesInTransaction:f},"committed transaction");break}catch(l){h.warn(`failed to commit ${Object.keys(g).length} mutations, tries left=${a}`),await (0,generics_1.delay)(k)}}else h.trace("no mutations in transaction")}finally{--b,
0===b&&(e={},g={},f=0)}return c}}};exports.addTransactionCapability=addTransactionCapability;
const initAuthCreds=()=>{const d=crypto_2.Curve.generateKeyPair();return{noiseKey:crypto_2.Curve.generateKeyPair(),pairingEphemeralKeyPair:crypto_2.Curve.generateKeyPair(),signedIdentityKey:d,signedPreKey:(0,crypto_2.signedKeyPair)(d,1),registrationId:(0,generics_1.generateRegistrationId)(),advSecretKey:(0,crypto_1.randomBytes)(32).toString("base64"),processedHistoryMessages:[],nextPreKeyId:1,firstUnuploadedPreKeyId:1,accountSyncCounter:0,accountSettings:{unarchiveChats:!1},registered:!1,pairingCode:void 0,
lastPropHash:void 0,routingInfo:void 0}};exports.initAuthCreds=initAuthCreds;
