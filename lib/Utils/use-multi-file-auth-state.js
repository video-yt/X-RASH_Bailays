Object.defineProperty(exports,"__esModule",{value:!0});exports.useMultiFileAuthState=void 0;
const async_mutex_1=require("async-mutex"),promises_1=require("fs/promises"),path_1=require("path"),WAProto_1=require("../../WAProto"),auth_utils_1=require("./auth-utils"),generics_1=require("./generics"),fileLocks=new Map,getFileLock=e=>{let f=fileLocks.get(e);f||(f=new async_mutex_1.Mutex,fileLocks.set(e,f));return f},useMultiFileAuthState=async e=>{const f=async(b,a)=>{const c=(0,path_1.join)(e,h(a));return getFileLock(c).acquire().then(async d=>{try{await (0,promises_1.writeFile)(c,JSON.stringify(b,
generics_1.BufferJSON.replacer))}finally{d()}})},k=async b=>{try{const a=(0,path_1.join)(e,h(b));return await getFileLock(a).acquire().then(async c=>{try{const d=await (0,promises_1.readFile)(a,{encoding:"utf-8"});return JSON.parse(d,generics_1.BufferJSON.reviver)}finally{c()}})}catch(a){return null}},p=async b=>{try{const a=(0,path_1.join)(e,h(b));return getFileLock(a).acquire().then(async c=>{try{await (0,promises_1.unlink)(a)}catch(d){}finally{c()}})}catch(a){}},l=await (0,promises_1.stat)(e).catch(()=>
{});if(l){if(!l.isDirectory())throw Error(`found something that is not a directory at ${e}, either delete it or specify a different location`);}else await (0,promises_1.mkdir)(e,{recursive:!0});const h=b=>{var a;return null===(a=null===b||void 0===b?void 0:b.replace(/\//g,"__"))||void 0===a?void 0:a.replace(/:/g,"-")},m=await k("creds.json")||(0,auth_utils_1.initAuthCreds)();return{state:{creds:m,keys:{get:async(b,a)=>{const c={};await Promise.all(a.map(async d=>{let g=await k(`${b}-${d}.json`);"app-state-sync-key"===
b&&g&&(g=WAProto_1.proto.Message.AppStateSyncKeyData.fromObject(g));c[d]=g}));return c},set:async b=>{const a=[];for(const c in b)for(const d in b[c]){const g=b[c][d],n=`${c}-${d}.json`;a.push(g?f(g,n):p(n))}await Promise.all(a)}}},saveCreds:async()=>f(m,"creds.json")}};exports.useMultiFileAuthState=useMultiFileAuthState;
