var __createBinding=this&&this.__createBinding||(Object.create?function(b,a,c,d){void 0===d&&(d=c);var e=Object.getOwnPropertyDescriptor(a,c);if(!e||("get"in e?!a.__esModule:e.writable||e.configurable))e={enumerable:!0,get:function(){return a[c]}};Object.defineProperty(b,d,e)}:function(b,a,c,d){void 0===d&&(d=c);b[d]=a[c]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(b,a){Object.defineProperty(b,"default",{enumerable:!0,value:a})}:function(b,a){b["default"]=a}),__importStar=
this&&this.__importStar||function(){var b=function(a){b=Object.getOwnPropertyNames||function(c){var d=[],e;for(e in c)Object.prototype.hasOwnProperty.call(c,e)&&(d[d.length]=e);return d};return b(a)};return function(a){if(a&&a.__esModule)return a;var c={};if(null!=a)for(var d=b(a),e=0;e<d.length;e++)"default"!==d[e]&&__createBinding(c,a,d[e]);__setModuleDefault(c,a);return c}}();Object.defineProperty(exports,"__esModule",{value:!0});
exports.signedKeyPair=exports.Curve=exports.generateSignalPubKey=void 0;exports.aesEncryptGCM=aesEncryptGCM;exports.aesDecryptGCM=aesDecryptGCM;exports.aesEncryptCTR=aesEncryptCTR;exports.aesDecryptCTR=aesDecryptCTR;exports.aesDecrypt=aesDecrypt;exports.aesDecryptWithIV=aesDecryptWithIV;exports.aesEncrypt=aesEncrypt;exports.aesEncrypWithIV=aesEncrypWithIV;exports.hmacSign=hmacSign;exports.sha256=sha256;exports.md5=md5;exports.hkdf=hkdf;exports.derivePairingCodeKey=derivePairingCodeKey;
const crypto_1=require("crypto"),libsignal=__importStar(require("libsignal")),Defaults_1=require("../Defaults"),{subtle}=globalThis.crypto,generateSignalPubKey=b=>33===b.length?b:Buffer.concat([Defaults_1.KEY_BUNDLE_TYPE,b]);exports.generateSignalPubKey=generateSignalPubKey;
exports.Curve={generateKeyPair:()=>{const {pubKey:b,privKey:a}=libsignal.curve.generateKeyPair();return{private:Buffer.from(a),public:Buffer.from(b.slice(1))}},sharedKey:(b,a)=>{b=libsignal.curve.calculateAgreement((0,exports.generateSignalPubKey)(a),b);return Buffer.from(b)},sign:(b,a)=>libsignal.curve.calculateSignature(b,a),verify:(b,a,c)=>{try{return libsignal.curve.verifySignature((0,exports.generateSignalPubKey)(b),a,c),!0}catch(d){return!1}}};
const signedKeyPair=(b,a)=>{const c=exports.Curve.generateKeyPair(),d=(0,exports.generateSignalPubKey)(c.public);b=exports.Curve.sign(b.private,d);return{keyPair:c,signature:b,keyId:a}};exports.signedKeyPair=signedKeyPair;const GCM_TAG_LENGTH=16;function aesEncryptGCM(b,a,c,d){a=(0,crypto_1.createCipheriv)("aes-256-gcm",a,c);a.setAAD(d);return Buffer.concat([a.update(b),a.final(),a.getAuthTag()])}
function aesDecryptGCM(b,a,c,d){a=(0,crypto_1.createDecipheriv)("aes-256-gcm",a,c);c=b.slice(0,b.length-GCM_TAG_LENGTH);b=b.slice(b.length-GCM_TAG_LENGTH);a.setAAD(d);a.setAuthTag(b);return Buffer.concat([a.update(c),a.final()])}function aesEncryptCTR(b,a,c){a=(0,crypto_1.createCipheriv)("aes-256-ctr",a,c);return Buffer.concat([a.update(b),a.final()])}function aesDecryptCTR(b,a,c){a=(0,crypto_1.createDecipheriv)("aes-256-ctr",a,c);return Buffer.concat([a.update(b),a.final()])}
function aesDecrypt(b,a){return aesDecryptWithIV(b.slice(16,b.length),a,b.slice(0,16))}function aesDecryptWithIV(b,a,c){a=(0,crypto_1.createDecipheriv)("aes-256-cbc",a,c);return Buffer.concat([a.update(b),a.final()])}function aesEncrypt(b,a){const c=(0,crypto_1.randomBytes)(16);a=(0,crypto_1.createCipheriv)("aes-256-cbc",a,c);return Buffer.concat([c,a.update(b),a.final()])}
function aesEncrypWithIV(b,a,c){a=(0,crypto_1.createCipheriv)("aes-256-cbc",a,c);return Buffer.concat([a.update(b),a.final()])}function hmacSign(b,a,c="sha256"){return(0,crypto_1.createHmac)(c,a).update(b).digest()}function sha256(b){return(0,crypto_1.createHash)("sha256").update(b).digest()}function md5(b){return(0,crypto_1.createHash)("md5").update(b).digest()}
async function hkdf(b,a,c){var d=b instanceof Uint8Array?b:new Uint8Array(b);b=c.salt?new Uint8Array(c.salt):new Uint8Array(0);c=c.info?(new TextEncoder).encode(c.info):new Uint8Array(0);d=await subtle.importKey("raw",d,{name:"HKDF"},!1,["deriveBits"]);a=await subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:b,info:c},d,8*a);return Buffer.from(a)}
async function derivePairingCodeKey(b,a){b=(new TextEncoder).encode(b);a=a instanceof Uint8Array?a:new Uint8Array(a);b=await subtle.importKey("raw",b,{name:"PBKDF2"},!1,["deriveBits"]);a=await subtle.deriveBits({name:"PBKDF2",salt:a,iterations:131072,hash:"SHA-256"},b,256);return Buffer.from(a)};
